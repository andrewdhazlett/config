{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":0,"width":2560,"height":1440},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/andrewhazlett/Dev/src/testingMeteor/source","buffers":[{"text":"---\ntitle: Mocha web\nslug: mocha-web\ndate: 0001/01/06\nnumber: 6\ncontents: \"Testing with meteor\"\n---\n{:note: .well .bg-warning}\n{:screenshot: .img-rounded .screenshot}\n{:table: .table .table-striped}\n\n## Mocha web\n\n[Mocha web](https://github.com/mad-eye/meteor-mocha-web) is a smart package (no other external components are needed!) put together by Michael Risse from MadEye. The goal of the package is:\n\n> meteor-mocha-web allows you to easily and safely run mocha tests within the Meteor framework. This means you can write tests that use and examine Meteor collections.\n\nAs the name and the description suggest, Mocha web is an adaptation of the [Mocha](http://visionmedia.github.io/mocha/) framework in order to be used with Meteor.\nMocha web has both a client side and server side testing setup, with both having a client side template that you can render in to your app somewhere.\n\n### Getting started\n\nFirst, install mocha-web using `mrt add mocha-web`. The next step is to add the reporters to a page that will show client and server runner test results.\n\nNow that the package is installed, clear the content of the default html and js files. Mocha web provides you dashboard to visualyze your tests results. Two templates are available: one for the client tests and one for the server tests. Put them in the default html apge and they will display the results of your tests. The templates are:\n\n<% book_code 'client/views/test.html', 'html' do %>\n<h1>Client Tests</h1>\n<div>\n  {{> mochaTestReport}}\n</div>\n<h1>Server Tests</h1>\n<div>\n  {{> serverTestReport}}\n</div>\n<% end %>\n\nNote in a full application you may put these templates where you want.\n\nGreat, now where should we put our tests? As we have client and server tests, let's follow the same convention as meteor:\n\n<pre>\n+-- tests\n|   +-- client\n|   |   +-- clientTests.js\n|   +-- server\n|   |   +-- serverTests.js\n</pre>\n\nLet's go back to our microphone examples to walk through mocha-web together. Starting with the minimongoid slugify test:\n\n<% book_code 'tests/clientTests.js', 'javascript' do %>\ndescribe(\"Episode\", function() {\n  describe(\"slugify on creation\", function() {\n    it(\"creates a slug from the title\", function() {\n      Episode.create({title: 'Episode 15 - Google Ventures'})\n      episode = Episode.first({title: 'Episode 15 - Google Ventures'})\n      chai.assert.equal('episode-15-google-ventures', episode.slug);\n      episode.destroy\n    });\n  });\n});\n<% end %>\n\nThe goal of this code is to ensure that we end up with a slug based on the title, once we create a new episode. With mocha-web this test may look like a unit-test, but we are actually writing an integration test because we are using several systems together to accomplish this test. If we wanted a true unit test, we could the slugify method itself and ensure it returns what we want. We will stick with the integration style because I know we want to ensure it happens before creation for any uploaded podcasts.\n\nSidenote: Because we are using several systems together any data we create is being inserted into our local development version of MongoDB. That is why we have the episode.destroy call at the end of the test.\n{: note}\n\nTo run your tests, you need to do two easy steps. The first step is to call `METEOR_MOCHA_TEST_DIRS='tests' meteor rebuild-all`, you need to run this any time you change/add files or change the file locations. Then just provide tha path to your tests directory (here tests) to the following command:\n\n<% book_code 'console', 'javascript' do %>\n    METEOR_MOCHA_TEST_DIRS=\"tests\" mrt\n<% end %>\n\nNow let's head to http://localhost:3000 and we should see the following:\n\n![MochaWeb first failure](./images/06-mocha-web/mochaweb-first-fail.png)\n{: screenshot}\n\nAs we can see we have two parts. The first for the client test we added and the second for the server, which did not display tests since we did not create any.\nIn the client report, we can see the file name 'clientTests', our test with its message and its status and finally on the top right we have the summary of our test suite.\n\nIf we add the code for slugify, we should get a green test suite on the page:\n\n<% book_code 'collection/episodes.coffee', 'coffeescript' do %>\nclass @Episode extends Minimongoid\n  @_collection: new Meteor.Collection('episodes')\n\n  @before_create: (episode) ->\n    episode.slug = Episode.slugify(episode.title)\n    episode.downloadCount = 0\n    episode\n\n  @slugify: (str) ->\n    str.toLowerCase().replace(/[^\\w ]+/g, \"\").replace(RegExp(\" +\", \"g\"), \"-\"):w\n\n<% end %>\n\nAnd now when we reload our web app, we should have a screen that shows our first success with Mocha-web!\n\n![MochaWeb first pass](./images/06-mocha-web/mochaweb-first.png)\n{: screenshot}\n\n\n### Testing the DOM\n\nLet's push the envelope a little and write an integration test that renders a template that we can run assertions against. The first step is to refactor the episode create and destroy into a before and after block, this allows us to share code amongst all the test in a describe block:\n\n<% book_code 'tests/clientTests.js', 'javascript' do %>\ndescribe(\"Episode\", function() {\n  var episode;\n\n  before(function() {\n    episode = Episode.create({title: 'Episode 15 - Google Ventures'})\n  });\n\n  after(function() {\n    episode.destroy()\n  });\n\n  describe(\"slugify on creation\", function() {\n    it(\"creates a slug from the title\", function() {\n      episode = Episode.first({title: 'Episode 15 - Google Ventures'})\n      episode.slug.should.equal('episode-15-google-ventures');\n    });\n  });\n});\n<% end %>\n\nNow when you look at the browser again, you should still see one test passing. Let's dive in to adding our first html integration test now.\n\n<% book_code 'tests/clientTests.js', 'javascript' do %>\n  describe(\"should display on the episodes template\", function() {\n    it(\"Title\", function() {\n      div = document.createElement(\"DIV\");\n      comp = UI.renderWithData(Template.episode, episode);\n      UI.insert(comp, div)\n      $(div).html().should.include('Episode 15 - Google Ventures')\n    });\n  });\n<% end %>\n\nWhat we do here is setup an empty div and create a component to render into it with our episode data object. We then insert the component into the div and check that the div contains our title inside the html. For the purpose of this test, we are assuming that Iron Router is setup and doing it's job correctly, that is why this is an integration test and not an acceptance test.\n\nHere is a quick stab at the html that should turn our failing test to green.\n\n<% book_code 'client/view/episodes/episodes.html', 'html' do %>\n<template name=\"episode\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col-md-8 col-md-offset-2\">\n        <article>\n          <h3>{{title}}</h3>\n        </article>\n      </div>\n    </div>\n  </div>\n</template>\n<% end %>\n\nAnd now we have a green integration level html test!\n\n![Mochaweb first html integration passing test](./images/06-mocha-web/mochaweb-first-html.png)\n{: screenshot}\n\nThis test isn't 100% right, we really want the title to link to the individual episode page, so let's refactor a bit on both the test and the html template. We'll start with refactoring the div setup in to a before block and then add a second test.\n\n<% book_code 'tests/clientTests.js', 'javascript' do %>\n describe(\"should display on the episodes template\", function() {\n    var div;\n\n    before(function() {\n      div = document.createElement(\"DIV\");\n      comp = UI.renderWithData(Template.episode, episode);\n      UI.insert(comp, div)\n    });\n\n    it(\"Title\", function() {\n      $(div).html().should.include('Episode 15 - Google Ventures')\n    });\n\n    it(\"with an episode link\", function() {\n      link = '<a href=\"/episode/episode-15-google-ventures\">Episode 15 - Google Ventures</a>'\n      $(div).html().should.include(link)\n    });\n  });\n<% end %>\n\nNow we have a failing test again, so let's tweak our html.\n\n<% book_code 'client/view/episodes/episodes.html', 'html' do %>\n<template name=\"episode\">\n  <div class=\"container\">\n    <div class=\"row\">\n      <div class=\"col-md-8 col-md-offset-2\">\n        <article>\n          <h3><a href=\"{{pathFor 'episode'}}\">{{title}}</a></h3>\n        </article>\n      </div>\n    </div>\n  </div>\n</template>\n<% end %>\n\nBam, green again! This is great, right? Nope, we have a problem.\n\n### Don't be brittle\n\nThe way we matched on this test actually gives you a brittle test. Suppose we need to add a click event or we need to target that anchor tag with some css, perhaps our designer jumps in and adds a class to the link:\n\n<% book_code 'client/view/episodes/episodes.html', 'html' do %>\n  <h3><a class=\"title-link\" href=\"{{pathFor 'episode'}}\">{{title}}</a></h3>\n<% end %>\n\nAll of a sudden our test is failing and the designer has no idea why! Let's refactor our test to only match on the url string we care about and then target our matcher better.\n\n\n<% book_code 'tests/clientTests.js', 'javascript' do %>\n  it(\"with an episode link\", function() {\n    link = '/episode/episode-15-google-ventures'\n    $(div).find('a').prop('href').should.include(link)\n  });\n<% end %>\n\nThe test is back to passing again and our designer can feel some relief that he didn't actually break anything.\n","markers":{"markers":{"1":{"id":1,"range":[[86,0],[95,77]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":18,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/andrewhazlett/Dev/src/testingMeteor/source/chapters/06-mocha-web.md.erb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"bccca8d055617e52462270671468bdfe975ce64c","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":18,"softTabs":true,"displayBuffer":{"id":19,"softWrap":true,"editorWidthInChars":230,"scrollTop":1244,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/andrewhazlett/Dev/src/testingMeteor/source/chapters/06-mocha-web.md.erb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/andrewhazlett/Dev/src/testingMeteor/source/chapters/06-mocha-web.md.erb","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":true,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/andrewhazlett/Dev/src/testingMeteor/source/chapters/06-mocha-web.md.erb":1402331617445},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":98190},"tree-view":{"directoryExpansionStates":{"chapters":{}},"selectedPath":"/Users/andrewhazlett/Dev/src/testingMeteor/source/chapters/06-mocha-web.md.erb","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}